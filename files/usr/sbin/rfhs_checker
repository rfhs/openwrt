#!/bin/ash
# RFHS checker script for realtime troubleshooting, status checking, and CI/CD
# check for ssid's working

set -eu

fail_count=0
if [ "${1:-}" = "excessive" ]; then
  excessive=1
else
  excessive=0
fi

wait_for_it() {
  iter=0
  if [ "${excessive}" = "1" ]; then
    while pgrep -f rfhs_wifi_fixer > /dev/null; do
      if [ "${iter}" -ge "60" ]; then
        printf "Timeout waiting for rfhs_wifi_fixer to do it's job.\n"
        exit 1
      fi
      printf "rfhs_wifi_fixer is prepping the system...\n"
      sleep 1
      iter=$((iter + 1))
    done
  fi
  while pgrep -f mac80211.sh > /dev/null; do
    if [ "${iter}" -ge "60" ]; then
      printf "Timeout waiting for mac80211.sh to do it's job.\n"
      exit 1
    fi
    printf "mac802.11.sh is configuring interfaces...\n"
    sleep 1
    iter=$((iter + 1))
  done
  while pgrep -f 'ubus call hostapd' > /dev/null; do
    if [ "${iter}" -ge "60" ]; then
      printf "Timeout waiting for 'ubus call hostapd to do it's job.\n"
      exit 1
    fi
    printf "ubus is still configuring hostapd...\n"
    sleep 1
    iter=$((iter + 1))
  done
  return 0
}

do_check() {
  check=0
  config="$(mktemp)"
  running="$(mktemp)"

  # Write status files which may or may not be used by code you will never see...
  if [ -d '/run/rfctf_status' ]; then
    for ssid in $(iwinfo | grep 'ESSID:' | awk '{gsub(/"/, "");print $3}' | sort -u | grep -v unknown); do
      touch "/run/rfctf_status/${ssid}_ap_running"
    done
  fi

  # get info for config check
  grep ' ssid ' /etc/config/wireless | grep -v '^#' | awk '{gsub("\047","");print $3}' | sort > "${config}"
  iwinfo | grep 'ESSID:' | awk '{gsub(/"/, "");print $3}' | sort | grep -v unknown > "${running}"
  # config check
  if ! diff -Naur "${config}" "${running}" > /dev/null 2>&1; then
    OLDIFS="${IFS}"
    IFS='
'
    for line in $(diff -Naur "${config}" "${running}"); do
      if echo "${line}" | grep -q -- '---'; then
        continue
      elif echo "${line}" | grep -q -- '+++'; then
        continue
      elif echo "${line}" | grep -q -- '@@'; then
        continue
      elif echo "${line}" | grep -q -- 'unknown'; then
        continue
      elif printf "%s" "${line}" | grep -q 'OpenWrt'; then
        continue
      fi
      if echo "${line}" | grep -q '^+'; then
        check=1
        printf "%s is running but not configured???\n" "${line/+/}"
        iwinfo | grep -A1 -- "${line/+/}"
      fi
      if echo "${line}" | grep -q '^-'; then
        check=1
        printf "%s is configured but not running\n" "${line/-/}"
        printf "\nUCI CONFIG:\n"
        grep -v '^#' /etc/config/wireless | grep -A1 -- " ssid .${line/-/}"
        printf "\nHOSTAPD Config:\n"
        awk "/^ssid=${line/-/}/{print FILENAME}" /var/run/*.conf
        printf "\nRUNNING:\n"
        iwinfo | grep -A2 -- "${line/-/}"
        printf "-------------------------------------------\n"
      fi
    done
    IFS="${OLDIFS}"
  fi
  rm -f "${config}" "${running}"
  for phy in $(grep ' phy ' /etc/config/wireless | grep -v '^#' | awk '{gsub("\047","");print $3}' | sort); do
    if ! iw "${phy}" info > /dev/null 2>&1; then
      check=1
      printf "%s is configured but missing\n" "${phy}"
    fi
  done
  if [ "${check}" = "0" ]; then
    printf "AP Status: Running config matches written config\n"
    printf "Wifi is UP\n"
  else
    if pgrep -f mac80211.sh > /dev/null 2>&1; then
      check=1
      printf "-------------------------------------------\n"
      printf "OpenWRT is still has mac80211.sh configuration processes running.\n"
    fi
  fi
  return "${check}"
}

if [ -f '.dockerenv' ]; then
  boot_timestamp="$(stat -c %Y /.dockerenv)"
  target_time=$(( 30 + boot_timestamp ))
  sleepy_tyme=$(( target_time - $(date +%s) ))
else
  # not in docker, assume uptime is when we booted
  sleepy_tyme=$(( 60 - $(awk -F. '{print $1}' /proc/uptime) ))
fi
if [ "${sleepy_tyme}" -gt "0" ]; then
  if [ "${sleepy_tyme}" -gt "60" ]; then
    #if the time skews during/after boot this number can end up huge
    #limit it to the a sane maximum
    sleepy_tyme=60
    #time looks skewed, so fix it for the next run
    #this will make the loop always think it's in docker but also not sleep every time it runs
    touch .dockerenv
  fi
  sleep "${sleepy_tyme}"
fi

if [ "${excessive}" = "1" ]; then
  for required_command in rfhs_predictable_phys grep sort iw sed xargs wc lsmod rmmod; do
    if [ ! -x "$(command -v ${required_command} 2>&1)" ]; then
      printf "Missing required command: %s\n" "${required_command}"
      fail_count=$((fail_count + 1))
    fi
  done
  for rfhs_command in iptables cat ip fakepop; do
    if [ ! -x "$(command -v ${rfhs_command} 2>&1)" ]; then
      printf "Missing rfhs command: %s\n" "${rfhs_command}"
      fail_count=$((fail_count + 1))
    fi
  done
fi
wait_for_it
sleep 1
wait_for_it
if do_check; then
  printf "Check Pass\n"
else
  printf "Check Failed\n"
  fail_count=$((fail_count + 1))
fi
# Add a check for setageing and maybe some other stuff like checking for uhttpd and dnsmasq running and matching config
exit "${fail_count}"
